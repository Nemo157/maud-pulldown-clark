var searchIndex = {};
searchIndex['maud_pulldown_cmark'] = {"items":[[0,"","maud_pulldown_cmark","This library implements an adapter to allow rendering strings as markdown inside a `maud`\nmacro using `pulldown-cmark` efficiently.",null,null],[4,"Markdown","","The adapter that allows rendering markdown inside a `maud` macro.",null,null],[13,"FromString","","To allow rendering from a string.",0,null],[11,"render","","",0,{"inputs":[{"name":"markdown"},{"name":"write"}],"output":{"name":"result"}}]],"paths":[[4,"Markdown"]]};
searchIndex['pulldown_cmark'] = {"items":[[0,"","pulldown_cmark","Pull parser for commonmark.",null,null],[3,"Parser","","",null,null],[3,"Options","","",null,null],[4,"Event","","",null,null],[13,"Start","","",0,null],[13,"End","","",0,null],[13,"Text","","",0,null],[13,"Html","","",0,null],[13,"InlineHtml","","",0,null],[13,"FootnoteReference","","",0,null],[13,"SoftBreak","","",0,null],[13,"HardBreak","","",0,null],[4,"Tag","","",null,null],[13,"Paragraph","","",1,null],[13,"Rule","","",1,null],[13,"Header","","",1,null],[13,"BlockQuote","","",1,null],[13,"CodeBlock","","",1,null],[13,"List","","",1,null],[13,"Item","","",1,null],[13,"FootnoteDefinition","","",1,null],[13,"Table","","",1,null],[13,"TableHead","","",1,null],[13,"TableRow","","",1,null],[13,"TableCell","","",1,null],[13,"Emphasis","","",1,null],[13,"Strong","","",1,null],[13,"Code","","",1,null],[13,"Link","","",1,null],[13,"Image","","",1,null],[0,"html","","HTML renderer that takes an iterator of events as input.",null,null],[5,"push_html","pulldown_cmark::html","",null,{"inputs":[{"name":"string"},{"name":"i"}],"output":null}],[11,"new","pulldown_cmark","",2,{"inputs":[{"name":"parser"},{"name":"str"}],"output":{"name":"parser"}}],[11,"new_ext","","",2,{"inputs":[{"name":"parser"},{"name":"str"},{"name":"options"}],"output":{"name":"parser"}}],[11,"get_offset","","",2,{"inputs":[{"name":"parser"}],"output":{"name":"usize"}}],[11,"next","","",2,{"inputs":[{"name":"parser"}],"output":{"name":"option"}}],[11,"fmt","","",1,{"inputs":[{"name":"tag"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"tag"}],"output":{"name":"tag"}}],[11,"fmt","","",0,{"inputs":[{"name":"event"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",3,null],[11,"cmp","","",3,{"inputs":[{"name":"options"},{"name":"options"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",3,{"inputs":[{"name":"options"},{"name":"options"}],"output":{"name":"option"}}],[11,"lt","","",3,{"inputs":[{"name":"options"},{"name":"options"}],"output":{"name":"bool"}}],[11,"le","","",3,{"inputs":[{"name":"options"},{"name":"options"}],"output":{"name":"bool"}}],[11,"gt","","",3,{"inputs":[{"name":"options"},{"name":"options"}],"output":{"name":"bool"}}],[11,"ge","","",3,{"inputs":[{"name":"options"},{"name":"options"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"options"}],"output":{"name":"options"}}],[11,"eq","","",3,{"inputs":[{"name":"options"},{"name":"options"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"options"},{"name":"options"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"options"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",3,{"inputs":[{"name":"options"}],"output":{"name":"options"}}],[11,"all","","Returns the set containing all flags.",3,{"inputs":[{"name":"options"}],"output":{"name":"options"}}],[11,"bits","","Returns the raw value of the flags currently stored.",3,{"inputs":[{"name":"options"}],"output":{"name":"u32"}}],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",3,{"inputs":[{"name":"options"},{"name":"u32"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",3,{"inputs":[{"name":"options"},{"name":"u32"}],"output":{"name":"options"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",3,{"inputs":[{"name":"options"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",3,{"inputs":[{"name":"options"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",3,{"inputs":[{"name":"options"},{"name":"options"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",3,{"inputs":[{"name":"options"},{"name":"options"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",3,{"inputs":[{"name":"options"},{"name":"options"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",3,{"inputs":[{"name":"options"},{"name":"options"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",3,{"inputs":[{"name":"options"},{"name":"options"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",3,{"inputs":[{"name":"options"},{"name":"options"}],"output":{"name":"options"}}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",3,{"inputs":[{"name":"options"},{"name":"options"}],"output":{"name":"options"}}],[11,"bitand","","Returns the intersection between the two sets of flags.",3,{"inputs":[{"name":"options"},{"name":"options"}],"output":{"name":"options"}}],[11,"sub","","Returns the set difference of the two sets of flags.",3,{"inputs":[{"name":"options"},{"name":"options"}],"output":{"name":"options"}}],[11,"not","","Returns the complement of this set of flags.",3,{"inputs":[{"name":"options"}],"output":{"name":"options"}}],[11,"from_iter","","",3,{"inputs":[{"name":"options"},{"name":"t"}],"output":{"name":"options"}}],[17,"OPTION_ENABLE_TABLES","","",null,null],[17,"OPTION_ENABLE_FOOTNOTES","","",null,null]],"paths":[[4,"Event"],[4,"Tag"],[3,"Parser"],[3,"Options"]]};
searchIndex['getopts'] = {"items":[[0,"","getopts","Simple getopt alternative.",null,null],[3,"Options","","A description of the options that a program can handle.",null,null],[3,"Matches","","The result of checking command line arguments. Contains a vector\nof matches and a vector of free strings.",null,null],[12,"free","","Free string fragments",0,null],[4,"ParsingStyle","","What parsing style to use when parsing arguments.",null,null],[13,"FloatingFrees","","Flags and \"free\" arguments can be freely inter-mixed.",1,null],[13,"StopAtFirstFree","","As soon as a \"free\" argument (i.e. non-flag) is encountered, stop\nconsidering any remaining arguments as flags.",1,null],[4,"HasArg","","Describes whether an option has an argument.",null,null],[13,"Yes","","The option requires an argument.",2,null],[13,"No","","The option takes no argument.",2,null],[13,"Maybe","","The option argument is optional.",2,null],[4,"Occur","","Describes how often an option may occur.",null,null],[13,"Req","","The option occurs once.",3,null],[13,"Optional","","The option occurs at most once.",3,null],[13,"Multi","","The option occurs zero or more times.",3,null],[4,"Fail","","The type returned when the command line does not conform to the\nexpected format. Use the `Debug` implementation to output detailed\ninformation.",null,null],[13,"ArgumentMissing","","The option requires an argument but none was passed.",4,null],[13,"UnrecognizedOption","","The passed option is not declared among the possible options.",4,null],[13,"OptionMissing","","A required option is not present.",4,null],[13,"OptionDuplicated","","A single occurrence option is being used multiple times.",4,null],[13,"UnexpectedArgument","","There's an argument being passed to a non-argument option.",4,null],[4,"FailType","","The type of failure that occurred.",null,null],[13,"ArgumentMissing_","","",5,null],[13,"UnrecognizedOption_","","",5,null],[13,"OptionMissing_","","",5,null],[13,"OptionDuplicated_","","",5,null],[13,"UnexpectedArgument_","","",5,null],[6,"Result","","The result of parsing a command line with a set of options.",null,null],[11,"new","","Create a blank set of options.",6,{"inputs":[{"name":"options"}],"output":{"name":"options"}}],[11,"parsing_style","","Set the parsing style.",6,{"inputs":[{"name":"options"},{"name":"parsingstyle"}],"output":{"name":"options"}}],[11,"opt","","Create a generic option group, stating all parameters explicitly.",6,{"inputs":[{"name":"options"},{"name":"str"},{"name":"str"},{"name":"str"},{"name":"str"},{"name":"hasarg"},{"name":"occur"}],"output":{"name":"options"}}],[11,"optflag","","Create a long option that is optional and does not take an argument.",6,{"inputs":[{"name":"options"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":{"name":"options"}}],[11,"optflagmulti","","Create a long option that can occur more than once and does not\ntake an argument.",6,{"inputs":[{"name":"options"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":{"name":"options"}}],[11,"optflagopt","","Create a long option that is optional and takes an optional argument.",6,{"inputs":[{"name":"options"},{"name":"str"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":{"name":"options"}}],[11,"optmulti","","Create a long option that is optional, takes an argument, and may occur\nmultiple times.",6,{"inputs":[{"name":"options"},{"name":"str"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":{"name":"options"}}],[11,"optopt","","Create a long option that is optional and takes an argument.",6,{"inputs":[{"name":"options"},{"name":"str"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":{"name":"options"}}],[11,"reqopt","","Create a long option that is required and takes an argument.",6,{"inputs":[{"name":"options"},{"name":"str"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":{"name":"options"}}],[11,"parse","","Parse command line arguments according to the provided options.",6,{"inputs":[{"name":"options"},{"name":"c"}],"output":{"name":"result"}}],[11,"short_usage","","Derive a short one-line usage summary from a set of long options.",6,{"inputs":[{"name":"options"},{"name":"str"}],"output":{"name":"string"}}],[11,"usage","","Derive a usage message from a set of options.",6,{"inputs":[{"name":"options"},{"name":"str"}],"output":{"name":"string"}}],[11,"eq","","",1,{"inputs":[{"name":"parsingstyle"},{"name":"parsingstyle"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"parsingstyle"},{"name":"parsingstyle"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"parsingstyle"}],"output":{"name":"parsingstyle"}}],[11,"eq","","",2,{"inputs":[{"name":"hasarg"},{"name":"hasarg"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"hasarg"},{"name":"hasarg"}],"output":{"name":"bool"}}],[11,"clone","","",2,{"inputs":[{"name":"hasarg"}],"output":{"name":"hasarg"}}],[11,"eq","","",3,{"inputs":[{"name":"occur"},{"name":"occur"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"occur"},{"name":"occur"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"occur"}],"output":{"name":"occur"}}],[11,"eq","","",0,{"inputs":[{"name":"matches"},{"name":"matches"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"matches"},{"name":"matches"}],"output":{"name":"bool"}}],[11,"clone","","",0,{"inputs":[{"name":"matches"}],"output":{"name":"matches"}}],[11,"eq","","",4,{"inputs":[{"name":"fail"},{"name":"fail"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"fail"},{"name":"fail"}],"output":{"name":"bool"}}],[11,"fmt","","",4,{"inputs":[{"name":"fail"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"fail"}],"output":{"name":"fail"}}],[11,"description","","",4,{"inputs":[{"name":"fail"}],"output":{"name":"str"}}],[11,"eq","","",5,{"inputs":[{"name":"failtype"},{"name":"failtype"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"failtype"},{"name":"failtype"}],"output":{"name":"bool"}}],[11,"clone","","",5,{"inputs":[{"name":"failtype"}],"output":{"name":"failtype"}}],[11,"opt_present","","Returns true if an option was matched.",0,{"inputs":[{"name":"matches"},{"name":"str"}],"output":{"name":"bool"}}],[11,"opt_count","","Returns the number of times an option was matched.",0,{"inputs":[{"name":"matches"},{"name":"str"}],"output":{"name":"usize"}}],[11,"opts_present","","Returns true if any of several options were matched.",0,null],[11,"opts_str","","Returns the string argument supplied to one of several matching options or `None`.",0,null],[11,"opt_strs","","Returns a vector of the arguments provided to all matches of the given\noption.",0,{"inputs":[{"name":"matches"},{"name":"str"}],"output":{"name":"vec"}}],[11,"opt_str","","Returns the string argument supplied to a matching option or `None`.",0,{"inputs":[{"name":"matches"},{"name":"str"}],"output":{"name":"option"}}],[11,"opt_default","","Returns the matching string, a default, or `None`.",0,{"inputs":[{"name":"matches"},{"name":"str"},{"name":"str"}],"output":{"name":"option"}}],[11,"fmt","","",4,{"inputs":[{"name":"fail"},{"name":"formatter"}],"output":{"name":"result"}}]],"paths":[[3,"Matches"],[4,"ParsingStyle"],[4,"HasArg"],[4,"Occur"],[4,"Fail"],[4,"FailType"],[3,"Options"]]};
searchIndex['maud'] = {"items":[[0,"","maud","A macro for writing HTML templates.",null,null],[3,"PreEscaped","","A wrapper that renders the inner value without escaping.",null,null],[3,"Escaper","","An adapter that escapes HTML special characters.",null,null],[3,"Utf8Writer","","Wraps a `std::io::Write` in a `std::fmt::Write`.",null,null],[8,"Render","","Represents a type that can be rendered as HTML.",null,null],[10,"render","","",0,{"inputs":[{"name":"render"},{"name":"write"}],"output":{"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"preescaped"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"render","","",1,{"inputs":[{"name":"preescaped"},{"name":"write"}],"output":{"name":"result"}}],[11,"new","","Creates an `Escaper` from a `std::fmt::Write`.",2,{"inputs":[{"name":"escaper"},{"name":"w"}],"output":{"name":"escaper"}}],[11,"into_inner","","Extracts the inner writer.",2,{"inputs":[{"name":"escaper"}],"output":{"name":"w"}}],[11,"write_str","","",2,{"inputs":[{"name":"escaper"},{"name":"str"}],"output":{"name":"result"}}],[11,"new","","Creates a `Utf8Writer` from a `std::io::Write`.",3,{"inputs":[{"name":"utf8writer"},{"name":"w"}],"output":{"name":"utf8writer"}}],[11,"into_inner","","Extracts the inner writer, along with any errors encountered\nalong the way.",3,null],[11,"into_result","","Drops the inner writer, returning any errors encountered\nalong the way.",3,{"inputs":[{"name":"utf8writer"}],"output":{"name":"result"}}],[11,"write_str","","",3,{"inputs":[{"name":"utf8writer"},{"name":"str"}],"output":{"name":"result"}}],[11,"write_fmt","","",3,{"inputs":[{"name":"utf8writer"},{"name":"arguments"}],"output":{"name":"result"}}]],"paths":[[8,"Render"],[3,"PreEscaped"],[3,"Escaper"],[3,"Utf8Writer"]]};
searchIndex['bitflags'] = {"items":[[0,"","bitflags","A typesafe bitmask flag generator.",null,null],[14,"bitflags!","","The `bitflags!` macro generates a `struct` that holds a set of C-style\nbitmask flags. It is useful for creating typesafe wrappers for C APIs.",null,null]],"paths":[]};
initSearch(searchIndex);
